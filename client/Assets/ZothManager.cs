using UnityEngine;
using System.Collections;

public class ZothManager : MonoBehaviour
{
    const float ZOTH_DURATION = 8f;
    const float LONG_FLASH_DURATION = 0.33f;

    public Transform[] explosion;
	public GameObject lightning;
	public float speedOffset;
	public float life;
	public float lifeAfterOff;
	public int branchesPerReceiver;
	public float lightningBoltJitter;
	public float lightningWidth;
	public float lightningFrequency;
	public float lightningPartBranch;
	public float lightningCurve;
    public Color color;

	// Use this for initialization
	void Start ()
    {
        StartCoroutine(ManageFlashes());
        StartCoroutine(ManageLightning());
        //StartCoroutine(ManageExpansion());
	}
	
	public IEnumerator ManageFlashes()
    {
        float end_time = Time.time + ZOTH_DURATION;
        float last_flash_time = end_time - LONG_FLASH_DURATION;

        // Darken the scene's directional light for the duration of the effect.
        GameGUI.instance.light.intensity = 0.7f;

        // Perform initial full strength flash.
        StartCoroutine(Flash(LONG_FLASH_DURATION, true, false));

        // Perform sporadic random flashes for the duration of the effect.
        while (Time.time < last_flash_time)
        {
            yield return new WaitForSeconds(Random.Range(0.3f, 1f));
            StartCoroutine(Flash(Random.Range(0.05f, LONG_FLASH_DURATION), false, false));
        }        

        // Restore the scene's directional light to its full intensity.
        GameGUI.instance.light.intensity = 1f;

        // Perform the final flash, at the end of which the effect object is destroyed.
	    StartCoroutine(Flash(LONG_FLASH_DURATION, true, true));
	}

    public IEnumerator Flash(float _duration, bool _full, bool _destroy)
    {
        float end_time = Time.time + _duration;

        if (GameData.instance.GetUserFlag(GameData.UserFlags.DISABLE_FLASH_EFFECTS) == false)
        {
            // Turn on the white flash GUI object, and blow out the ambient lighting.
            GameGUI.instance.flashObject.SetActive(true);
            RenderSettings.ambientIntensity = 10f;
        }

        // if the effect gameobject will be destroyed atfter this flash, hide its child objects now so they don't briefly reappear after the flash.
        if (_destroy)
        {
            this.gameObject.transform.GetChild(0).gameObject.SetActive(false);
            this.gameObject.transform.GetChild(1).gameObject.SetActive(false);
        }

        // For the duration of the flash, randomly change the alpha of the white flash object.
        while (Time.time < end_time)
        {
            GameGUI.instance.flashImage.color = new Color(1f, 1f, 1f, _full ? 1f : Random.Range(0.4f, 1f));
            yield return new WaitForSeconds(0.01f);
        }

        if (GameData.instance.GetUserFlag(GameData.UserFlags.DISABLE_FLASH_EFFECTS) == false)
        {
            // Turn the white flash GUI object off again, and restore the ambient lighting to its normal value.
            GameGUI.instance.flashObject.SetActive(false);
            RenderSettings.ambientIntensity = 1f;
        }

        // Destroy this effect game object if appropriate.
        if (_destroy) {
            Object.Destroy(this.gameObject);
        }
    }

    public IEnumerator ManageLightning()
    {
        float end_time = Time.time + ZOTH_DURATION;

        // Perform sporadic lightning bolts for the duration of the effect.
        while (Time.time < end_time)
        {
            yield return new WaitForSeconds(Random.Range(0.01f, 0.15f));

            Vector3 target = new Vector3(gameObject.transform.position.x + Random.Range(-400f, 400f), MapView.LAND_LEVEL, gameObject.transform.position.z + Random.Range(-400f, 400f));
            Vector3 source = new Vector3(target.x + Random.Range(-50f, 50f), 500f, target.z + Random.Range(-50f, 50f));

            // Below generated by Procedural Lightning's DemoSceneConfigureScript.unity scene.

            // Important, make sure this script is assigned properly, or you will get null ref exceptions.
            DigitalRuby.ThunderAndLightning.LightningBoltScript script = gameObject.GetComponent<DigitalRuby.ThunderAndLightning.LightningBoltScript>();
            int count = 5;
            float duration = 0.25f;
            float delay = 0.0f;
            int seed = 816986072;
            System.Random r = new System.Random();
            Vector3 start = source;
            Vector3 end = target;
            int generations = 6;
            float chaosFactor = 0.2460316f;
            float trunkWidth = 4f;
            float glowIntensity = 0.1317461f;
            float glowWidthMultiplier = 2f;
            float forkedness = 0.6190475f;
            float singleDuration = Mathf.Max(1.0f / 30.0f, (duration / (float)count));
            float fadePercent = 0.1547618f;
            float growthMultiplier = 0f;

            while (count-- > 0)
            {
                DigitalRuby.ThunderAndLightning.LightningBoltParameters parameters = new DigitalRuby.ThunderAndLightning.LightningBoltParameters
                {
                    Start = start,
                    End = end,
                    Generations = generations,
                    LifeTime = (count == 1 ? singleDuration : (singleDuration * (((float)r.NextDouble() * 0.4f) + 0.8f))),
                    Delay = delay,
                    ChaosFactor = chaosFactor,
                    TrunkWidth = trunkWidth,
                    GlowIntensity = glowIntensity,
                    GlowWidthMultiplier = glowWidthMultiplier,
                    Forkedness = forkedness,
                    Random = r,
                    FadePercent = fadePercent, // set to 0 to disable fade in / out
                    GrowthMultiplier = growthMultiplier
                };
                script.CreateLightningBolt(parameters);
                delay += (singleDuration * (((float)r.NextDouble() * 0.8f) + 0.4f));
            }
        }        
    }

    /*
    public IEnumerator ManageExpansion()
    {
        float start_time = Time.time;

        ParticleSystem.VelocityOverLifetimeModule velMod = gameObject.transform.GetChild(0).gameObject.GetComponent<ParticleSystem>().velocityOverLifetime;
        ParticleSystem.MinMaxCurve rate_x = velMod.x;
        ParticleSystem.MinMaxCurve rate_y = velMod.y;
        ParticleSystem.MinMaxCurve rate_z = velMod.z;

        for (;;)
        {
            float progress = (Time.time - start_time) / ZOTH_DURATION;

            if (progress > 1f) {
                break;
            }

            //rate_x.curveScalar = progress * 5f;
            rate_x.constantMax = progress * 50f;
            rate_y.constantMax = progress * 50f;
            rate_z.constantMax = progress * 50f;
            Debug.Log("x changed to: " + rate_x.constantMax);

            velMod.x = rate_x;
            velMod.y = rate_y;
            velMod.z = rate_z;

            yield return new WaitForSeconds(0.3f);
        }
    }
    */
}
